<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta property="og:description" content="论文巧妙地基于one stage目标检测算法提出实时实例分割算法YOLACT，整体的架构设计十分轻量，在速度和效果上面达到很好的trade off。 来源：【晓飞的算法工程笔记】 公众号 论文: YO" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>YOLACT : 首个实时one-stage实例分割模型，29.8mAP/33.5fps | ICCV 2019 - 晓飞的算法工程笔记 - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=KCO3_f2W_TC__-jZ7phSnmoFkQuWMJH2yAgA16eE3eY" />
    <link id="MainCss" rel="stylesheet" href="/skins/coffee/bundle-coffee.min.css?v=KPz7rj-c2sTAV1_ck1aDmbZcuCG3KBhyLnfvzf6nn94" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/coffee/bundle-coffee-mobile.min.css?v=na9bpAY4yh7uEWCcrXj3vfJM3VBse8YtU6-5fUUQPz0" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/VincentLee/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/VincentLee/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/VincentLee/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=98Fvfd6UZH20B_MF08daNaODjSu879MVR9RHmyvWAlg"></script>
    <script>
        var currentBlogId = 215477;
        var currentBlogApp = 'VincentLee';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'coffee';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a href="https://www.cnblogs.com/VincentLee/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/VincentLee/">晓飞的算法工程笔记</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="navigator">
			
<ul id="navList">
	<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
	<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/VincentLee/">
首页</a>
</li>
	<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
	<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E6%99%93%E9%A3%9E%E7%9A%84%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0">
联系</a></li>
	<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
	<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/VincentLee/rss/">
订阅</a>
	
<a id="blog_nav_rss_image" href="https://www.cnblogs.com/VincentLee/rss/">
    <img src="/skins/coffee/images/xml.gif" alt="订阅" />
</a></li>
</ul>



			<div class="blogStats">
				
				<!--done-->
随笔- 
38&nbsp;
文章- 
0&nbsp;
评论- 
2&nbsp;



				
			</div><!--end: blogStats -->
		</div><!--end: navigator 博客导航栏 -->
		<div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class = "postTitle">
			
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/VincentLee/p/12843133.html">YOLACT : 首个实时one-stage实例分割模型，29.8mAP/33.5fps | ICCV 2019</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
    <blockquote>
<p>论文巧妙地基于one-stage目标检测算法提出实时实例分割算法YOLACT，整体的架构设计十分轻量，在速度和效果上面达到很好的trade-off。<br>
 <br>
来源：【晓飞的算法工程笔记】 公众号</p>
</blockquote>
<p><strong>论文: YOLACT: Real-time Instance Segmentation</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-9981e87f52e1ecd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><strong>论文地址：<a href="https://arxiv.org/abs/1904.02689">https://arxiv.org/abs/1904.02689</a></strong></li>
<li><strong>论文代码：<a href="https://github.com/dbolya/yolact">https://github.com/dbolya/yolact</a></strong></li>
</ul>
<h1 id="introduction">Introduction</h1>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-a43e0c59cf2f6d27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>  目前的实例分割方法虽然效果都有很大的提升，但是均缺乏实时性，为此论文的提出了首个实时($&gt;30fps$)实例分割算法YOLACT，论文的主要贡献如下：</p>
<ul>
<li>基于one-stage目标检测算法，提出实时实例分割算法YOLACT，整体的架构设计十分轻量，在速度和效果上面达到很好的trade-off。</li>
<li>提出加速版NMS算法Fast NMS，有12ms加速</li>
</ul>
<h1 id="yolact">YOLACT</h1>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-d01b7181f7425efb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>  YOLACT的主要想法是直接在one-stage目标检测算法中加入Mask分支，而不添加任何的RoI池化的操作，将实例分割分成两个并行的分支：</p>
<ul>
<li>使用FCN来生成分辨率较大的原型mask，原型mask不针对任何的实例。</li>
<li>目标检测分支添加额外的head来预测mask因子向量，用于对原型mask进行特定实例的加权编码。</li>
</ul>
<p>  这样做的原理在于，mask在空间上是连续的，卷积能很好地保持这种特性，因此原型mask通过全卷积生成的，而全连接层虽然不能保持空间连贯性，但能很好地预测语义向量，于是用来生成instance-wise的mask因子向量，结合两者进行预测，既能保持空间连贯性，也能加入语义信息并保持one-stage的快速性。最后取目标检测分支经过NMS后的实例，逐个将原型mask和mask因子向量相乘，再将相乘后的结果合并输出</p>
<h3 id="prototype-generation">Prototype Generation</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-9f5fb05c92cb793c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>  原型mask分支预测$k$个mask，protonet按如图3的FCN形式实现，最后的卷积输出channel为$k$，protonet接在主干网络上。整体的实现与大多数的语义分割模型类似，区别在于主干网络使用了FPN来增加网络的深度，并且保持较大的分辨率($P_3$, 原图1/4大小)来提高小物体的识别。另外，论文发现不限制protonet的输出是很重要的，能够让网络对十分确定的原型给予压倒性的响应(比如背景)，可以选择对输出的原型mask进行ReLU激活或不接激活，论文最终选择了ReLU激活。</p>
<h3 id="mask-coefficients">Mask Coefficients</h3>
<p>  在经典的anchor-based目标检测算法中，检测head一般有两个分支，分别预测类别和bbox偏移。在此基础上添加第三个用于mask因子预测的分支，每个实例预测$k$个mask因子。<br>
  为了更好地控制和丰富原型mask的融合，对mask因子进行tanh激活，使得值更稳定且有正负，效果如图2的分支。</p>
<h3 id="mask-assembly">Mask Assembly</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-f5eb4ca287d98508.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>  将原型mask和mask因子进行线性组合，然后对组合结果进行sigmoid激活输出最终的mask。$P$为$h\times w\times k$的原型mask，$C$为$n\times k$的原型因子，$n$为检测分支NMS和分数过滤后留下的实例数。</p>
<ul>
<li>
<h5 id="losses">Losses</h5>
</li>
</ul>
<p>  训练的损失函数包含3种：分类损失$L_{cls}$、box回归损失$L_{box}$以及mask损失$L_{mask}$，权重分别为1、1.5和6.125，分类损失和回归损失的计算与SSD一样，mask损失使用pixel-wise的二元交叉熵计算$L_{mask}=BCE(M, M_{gt})$</p>
<ul>
<li>
<h5 id="cropping-masks">Cropping Masks</h5>
</li>
</ul>
<p>  在推理阶段，使用预测的bbox在最终的mask截取出实例，再使用阈值(人工设置0.5)来过滤成二值的mask。在训练的时候，则使用GT来截取实例计算mask损失，$L_{mask}$会除以截取的实例大小，这样有助于保留原型中的小目标。</p>
<h3 id="emergent-behavior">Emergent Behavior</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-a2cc8e2fa20bf345.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>  一般而言，FCN做分割都需要添加一些额外的trick来增加平移可变性，比如position-sensitive特征图，虽然YOLACT唯一增加平移可变形的措施是对最终的mask进行截取输出，但是论文发现对于中大物体不截取输出的效果也不错，这代表YOLACT的原型mask学到了对不同的实例进行不同的响应，如图5所示，适当地对原型mask进行组合就能得出实例。需要注意的是全红的输入图片，其原型mask特征是各不一样的，这是由于每次卷积都会padding，使得边界存在可区分性，所以主干网络本身就存在一定的平移可变形。</p>
<h3 id="backbone-detector">Backbone Detector</h3>
<p>  原型mask和mask因子的预测都需要丰富的特征，为了权衡速度和特征丰富性，主干网络采用类似与RetinaNet的结构，加入FPN，去掉$P_2$加入$P_6$和$P_7$，在多层中进行head预测，并用$P_3$特征进行原型mask预测。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-242735e71dc748be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>  YOLACT head使用$P_2 \sim P_7$的特征，anchor的大小分别对应$[24, 48, 96, 192, 384]$，每个head共享一个$3\times 3$卷积，然后再分别通过独立的$3\times 3$卷积进行预测，比RetinaNet更轻量，如图4。使用smooth-$L1$训练bbox预测，使用带背景类的softmax交叉熵训练分类预测，OHEM正负比例为$1:3$。</p>
<h1 id="other-improvements">Other Improvements</h1>
<hr>
<h3 id="fast-nms">Fast NMS</h3>
<p>  正常的NMS会串行地按类别将bbox逐个校验，这种效率对于5fps的算法是足够快的，但对于30fps的算法将是很大的瓶颈。为此，论文提出Fast NMS来加速。<br>
  首先根据类别分数对各检测结果进行排序，然后计算各自的IoU对，得到$c\times n\times n$的IoU矩阵$X$，$c$为类别数，$n$为bbox数量。假设与bbox的IoU高于阈值$t$的其它bbox的分数高于当前框，则去掉该bbox，计算逻辑如下：</p>
<ul>
<li>将矩阵$X$的下三角和对角线置为0，$X_{kij}=0, \forall k, j, i \ge j$</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-f86a558dc0735661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>取每列的最大值，计算如公式2，得到最大IoU值矩阵$K$</li>
<li>$K&lt;t$的检测结果即为每个类别保留的结果。</li>
</ul>
<p>  通过实验，FastNMS大约能比原生的NMS快约11.8ms，mAP下降0.1</p>
<h3 id="semantic-segmentation-loss">Semantic Segmentation Loss</h3>
<p>  为了提升准确率而不影响推理的速度，在训练阶段加入语义分割分支并计算语义分割损失辅助训练。在$P_3$输出上接一个c维的$1\times 1$卷积，由于一个像素可能属于多个类别，使用sigmoid激活输出而不是softmax激活，损失的权重为1，大约能提升0.4mAP。</p>
<h1 id="results">Results</h1>
<hr>
<h3 id="mask-results">Mask Results</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-5cc7294be8cb2c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-5522ddd08af163c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="mask-quality">Mask Quality</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-1c85c9a09ec26293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="ablations">Ablations</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-6925a26198ebe124.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="conclusion">CONCLUSION</h1>
<hr>
<p>  论文巧妙地基于one-stage目标检测算法提出实时实例分割算法YOLACT，整体的架构设计十分轻量，在速度和效果上面达到很好的trade-off。</p>
<p> <br>
 <br>
 </p>
<blockquote>
<p>写作不易，未经允许不得转载～<br>
更多内容请关注 微信公众号【晓飞的算法工程笔记】</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/20428708-7156c0e4a2f49bd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="work-life balance."></p>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
		</div>
		<div class="postDesc">posted @ 
<span id="post-date">2020-05-07 15:02</span>&nbsp;
<a href="https://www.cnblogs.com/VincentLee/">晓飞的算法工程笔记</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12843133" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12843133);return false;">收藏</a></div>
	</div>
	
	
</div><!--end: topics 文章、评论容器-->
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 215477, cb_blogApp = 'VincentLee', cb_blogUserGuid = '0d9ecd5d-98a6-e411-b908-9dcfd8948a71';
    var cb_entryId = 12843133, cb_entryCreatedDate = '2020-05-07 15:02', cb_postType = 1; 
    loadViewCount(cb_entryId);
    loadSideColumnAd();
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div></div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

<div id="sidebar_ad"></div>
			<div id="calendar"><div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script></div>
			
			<DIV id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</DIV>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 晓飞的算法工程笔记
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    
</body>
</html>